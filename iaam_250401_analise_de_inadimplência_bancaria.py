# -*- coding: utf-8 -*-
"""IAAM_250401_Analise_de_Inadimplência_Bancaria.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G_KcMOPLJ7--_oTxLpNxTT6yRvZzezGY
"""

# 01 - IMPORTAÇÃO DA BASE DE DADOS:

# Importação das Libs / Modulos:
import pandas as pd

# Importação da Base de Dados:
URL = "https://raw.githubusercontent.com/profviniciusheltai/AulaIA/refs/heads/main/base_financiamento_50mil.csv"
df = pd.read_csv(URL)

# Visualização Inicial dos Dados:
display(df.head())
print(df['inadimplente'].value_counts())

# 02 - PRE-VISUALIZAÇÃO DOS DADOS (GRAFICOS):

# Importação das Libs / Modulos:
import matplotlib.pyplot as plt
import seaborn as sns

# Grafico - Distribuição de Inadiplentes:
plt.figure(figsize=(6,4))
sns.countplot(data=df, x='inadimplente')
plt.title("Distribuição de Inadimplência")
plt.xlabel("Inadimplente (0 = Não, 1 = Sim)")
plt.ylabel("Quantidade")
plt.show()

# Grafico - Dispersão: Score x Valor do Financiamento:
plt.figure(figsize=(8,6))
sns.scatterplot(data=df, x='score_credito', y='valor_financiamento', hue='inadimplente')
plt.xlabel("Credito Score")
plt.ylabel("Valor Financiamento [R$]")
plt.show()

# Grafico - Mapa de Correlação:
plt.figure(figsize=(10,6))
sns.heatmap(df.corr(), annot=True, cmap='coolwarm')
plt.title("Mapa de Correlação das Variaveis")
plt.show()

# Grafico - Grafico de Pares (Amostras):
sns.pairplot(df.sample(1000), hue='inadimplente')
plt.suptitle("Grafico de Pares (Amostra)", y=1.02)
plt.show()

# 03 - CRIAÇÃO DA BASE (TREINO / TESTE)

# Importação das Libs / Modulos:
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score

# Separar dados:
x = df.drop('inadimplente', axis=1)
y = df['inadimplente']

# Normalização (Pre-Processamento):
scaler = StandardScaler()
scaled_x = scaler.fit_transform(x)

# Criação das Bases de Treino / Teste:
treino_x, teste_x, treino_y, teste_y = train_test_split(
    scaled_x, y, test_size=0.3, random_state=42)

# Verificação Final da Base:
print(teste_x)
print(teste_y)

# 04 - AVALIAÇÃO DOS MODELOS:

# Importação das Libs/Modulos:
from sklearn.metrics import accuracy_score
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix

# Função que vai analisar os modelos (avaliar):
def avaliar_modelo(modelo, nome):
  modelo.fit(treino_x, treino_y)
  predicao_y = modelo.predict(teste_x)

  # Apresentando os resultados:
  print("****************************************** ")
  print(f"\n Modelo: {nome} \n -------------------- \n")
  print(" -> Acuracia:", round(accuracy_score(teste_y, predicao_y), 4))
  print(" -> Relatorio de Classificação: \n", classification_report(teste_y, predicao_y))
  print(" -> Matriz de Confusão: \n", confusion_matrix(teste_y, predicao_y))

  scores = cross_val_score(modelo, scaled_x, y, cv=5)
  print(" -> Validação Cruzada (5-fold):", scores)
  print(" -> Media da CV: ", round(scores.mean(), 4))

# Entrada dos Modelos para Avaliação:

# Importação das Libs/Modulos:
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier

# Aplicação da Avaliação dos Modelos:
avaliar_modelo(LogisticRegression(), "Regressão Logistica")
avaliar_modelo(KNeighborsClassifier(n_neighbors=5), "KNN")
avaliar_modelo(DecisionTreeClassifier(), "Árvore de Decisão")

RandomForest = RandomForestClassifier(n_estimators = 100, random_state = 42)
avaliar_modelo(RandomForest, "Random Forest")

# 05 - ESCOLHA DO MODELO PARA PREDIÇÃO:

# Escolhendo o modelo de Predição para o Projeto:
modelo = RandomForestClassifier(n_estimators = 100, random_state = 42)
modelo.fit(treino_x, treino_y)

# 06 - APLICAÇÃO DA PREDIÇÃO INTERATIVA:

# Função para executar a predição com o usuario:
def prever_inadimplencia(idade, renda_mensal, valor_financiamento, anos_trabalho, score_credito):
  print("Informe os dados do cliente:")

  try:
    entrada = pd.DataFrame([{
        'idade': idade,
        'renda_mensal': renda_mensal,
        'valor_financiamento': valor_financiamento,
        'anos_trabalho': anos_trabalho,
        'score_credito': score_credito
    }])

    entrada_scaled = scaler.transform(entrada)
    pred = modelo.predict(entrada_scaled)[0]
    prob = modelo.predict_proba(entrada_scaled)[0]

    print("\n **** RESULTADO DA PREDIÇÃO ****")
    print(f"  -> Inadimplente: {'Sim' if pred == 1 else 'Não'}")
    print(f"  -> Prob. de Inadimplencia: {round(prob[1]*100, 2)}%")
    print(f"  -> Prob. de Adimplencia  : {round(prob[0]*100, 2)}%")

  except Exception as e:
    print("ERRO ao Processar os Dados")
    print("Erro:", e)

# Chama a Função:
prever_inadimplencia(24, 1500.20, 4050.00, 20, 8)

# 07 - CRIANDO INTERFACE PARA COLAB E JUPYPER:

# Importação da Lib / Modulo
from IPython.display import display
import ipywidgets as widgets

def formulario():
  idade = widgets.FloatText(description="Idade:")
  renda = widgets.FloatText(description="Renda Mensal:")
  valor = widgets.FloatText(description="Valor Financiamento:")
  tempo = widgets.FloatText(description="Anos Trabalhado:")
  score = widgets.FloatText(description="Score Credito:")

  botao = widgets.Button(description="Prever Inadimplencia")

  def ao_clicar(b):
    entrada = pd.DataFrame([{
        'idade': idade.value,
        'renda_mensal': renda.value,
        'valor_financiamento': valor.value,
        'anos_trabalho': tempo.value,
        'score_credito': score.value
    }])

    entrada_scaled = scaler.transform(entrada)
    pred = modelo.predict(entrada_scaled)[0]
    prob = modelo.predict_proba(entrada_scaled)[0]

    print("\n **** RESULTADO DA PREDIÇÃO ****")
    print(f"  -> Inadimplente: {'Sim' if pred == 1 else 'Não'}")
    print(f"  -> Prob. de Inadimplencia: {round(prob[1]*100, 2)}%")
    print(f"  -> Prob. de Adimplencia  : {round(prob[0]*100, 2)}%")

  botao.on_click(ao_clicar)
  display(idade, renda, valor, tempo, score, botao)

formulario()